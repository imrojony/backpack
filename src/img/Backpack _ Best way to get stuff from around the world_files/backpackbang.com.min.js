(function(){var enhancements = [{"filter":{"active":1,"enhancement_id":1372,"id":1383,"name":"","type":"exact_match","value":"/"},"id":1372,"name":"Title + Meta Description Change","recipes":[{"active":1,"enhancement_id":1372,"id":1602,"instructions":[{"active":1,"attr_key":"","attribute_key":null,"created_at":"2018-10-10T05:17:48.000Z","id":3803,"ins_value":null,"method":"Inner Text","name":"","pattern":null,"position":0,"recipe_id":1602,"selector":"Title","type":"take-constant--passthru--put-dom","updated_at":"2018-10-10T05:17:48.000Z","value":"This is where the new title text should go.","workspace_input_key":"","workspace_output_key":""},{"active":1,"attr_key":"","attribute_key":null,"created_at":"2018-10-10T05:17:48.000Z","id":3804,"ins_value":null,"method":"Attribute","name":"","pattern":null,"position":0,"recipe_id":1602,"selector":"meta[name=description]","type":"take-constant--passthru--put-dom","updated_at":"2018-10-10T05:17:48.000Z","value":"This is where the new meta description text should go.","workspace_input_key":"","workspace_output_key":""}],"name":"Recipe","position":0,"weight":1}],"site_id":151,"status":"Inactive"}];function paint(middleware, enhancements) {
  function isValidEnhancement(mw) {
    var currentPath = mw.getCurrentPath();

    function isMatchingFilter(en) {
      if (window.location.search.indexOf('rs-deactivate=all') > -1) {
        const m = 'All enhancements were disabled with ?rs-deactivate=all';
        mw.logError(m, 'rs-deactivate');
        return false;
      }
      if (en.status === 'Inactive' && window.location.search.indexOf('rs-test') === -1) {
        return false;
      }
      var f = en.filter;
      switch (f.type) {
        case 'exact_match':
          return currentPath === f.value;
        case 'prefix':
          return currentPath.indexOf(f.value) === 0;
        case 'regex':
          var isValidReg = true;
          try {
            new RegExp(String(f.value));
          } catch(e) {
            isValidReg = false;
          }
          if (isValidReg) {
            return currentPath.match(f.value);
          } else if (window.location.search.indexOf('rs-test=') > -1) {
            try {
              return currentPath.match(f.value);
            } catch(e) {
              mw.logError(e.toString(), 'rs-test bad regex');
              return false;
            }
          } else {
            return false;
          }
        default:
          return false;
      }
    };

    var params = mw.getRsParams();
    if (params['rs-test']) {
      return function isMatchingFilterAndIsTesting(en) {
        var shouldRun = Number(en.id) === Number(params['rs-test']) && isMatchingFilter(en);
        if (shouldRun) {
          mw.logError('Enhancement with id ' + String(en.id) + ' currently being tested with `?rs-test`.', 'announce rs-test');
          return true;
        } else {
          return false;
        }
      }
    } else {
      return isMatchingFilter;
    }
  }

  function chooseInstructionSequence(mw) {
    return function applyHashMiddleware(en) {
      return mw.chooseInstructionSequence(en, mw.getCurrentPath());
    };
  }

  function getWorkspaceInputKey(ws, instruction) {
    var toWrite = ws[instruction.workspace_input_key];
    if (!toWrite) {
      throw "RS-MissingWorkspaceItemError: no item named `" + instruction.workspace_input_key + "` in workspace.";
    }
    return toWrite;
  }

  function chooseInstructionExecutor(instruction) {
    switch (instruction.type) {
      case 'take-constant--passthru--put-dom':
        return function takeConstantPassthruPutDom(mw, ws, i) {
          mw.setHtml(i, i.value);
          return ws;
        };

      case 'take-workspace--passthru--put-dom':
        return function takeWorkspacePassthruPutDom(mw, ws, i) {
          var toWrite = getWorkspaceInputKey(ws, i);
          mw.setHtml(i, toWrite);
          return ws;
        };

      case 'take-dom--passthru--put-workspace':
        return function takeDomPassthruPutWorkspace(mw, ws, i) {
          var html = mw.getHtml(i);
          ws[i.workspace_output_key] = html;
          return ws;
        };

      case 'take-workspace--extract-with-pattern--put-workspace':
        return function takeWorkspaceExtractWithPatternPutWorkspace(mw, ws, i) {
          var toExtractFrom = getWorkspaceInputKey(ws, i);
          var protectBrackets = i.pattern.replace(/{{/g, 'AAABBCCCC').replace(/}}/g, 'DDDEEFFFF');
          var escapedSpecialChars = protectBrackets.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
          var restoreBrackets = escapedSpecialChars.replace(/AAABBCCCC/g, '{{').replace(/DDDEEFFFF/g, '}}');
          var regex = restoreBrackets.replace(/{{.+?}}/g, '([\\s\\S]+)').replace(/\\ /g, '\\s+');
          var match = toExtractFrom.match(regex);
          if (!match) {
            throw "RS-WorkspaceExtractPatternError: pattern `" + i.pattern + "` does not match workspace item `" + i.workspace_input_key + "` with value `" + toExtractFrom + "`.";
          }

          i.pattern.match(/{{.+?}}/g).forEach(function addNewWorkspaceItem(str, idx) {
            var newWorkspaceItem = str.slice(2, str.length - 2).trim();
            ws[newWorkspaceItem] = match[idx + 1];
          });

          return ws;
        };

        case 'take-workspace--set-with-pattern--put-workspace':
          return function takeWorkspaceSetWithPatternPutWorkspace(mw, ws, i) {
            i.pattern.match(/{{.+?}}/g).forEach(function verifyItemExists(str) {
              var item = str.slice(2, str.length - 2).trim();
              if (!ws[item]) {
                throw "RS-WorkspaceSetPatternError: pattern `" + i.pattern + "` contains item `" + item + "`, which is not in workspace.";
              }
            });

            var out = i.pattern.match(/{{.+?}}/g).reduce(function populatePattern(template, next) {
              var item = next.slice(2, next.length - 2).trim();
              var val = ws[item];
              var newTemplate = template.replace(next, val);
              return newTemplate;
            }, i.pattern);

            ws[i.workspace_output_key] = out;
            return ws;
          };

      case 'take-workspace--titlecase--put-workspace':
        return function takeWorkspaceTitlecasePutWorkspace(mw, ws, i) {
          var toTitlecase = getWorkspaceInputKey(ws, i);
          var titlecased = toTitlecase.split(' ').map(function titlecase(str) {
            return str[0].toUpperCase() + str.slice(1).toLowerCase();
          }).join(' ');
          ws[i.workspace_output_key] = titlecased;
          return ws;
        };

      case 'take-workspace--prepend-dom':
        return function takeDomPutWorkspacePutDom(mw, ws, i) {
          var htmlToChange = mw.getHtml(i);
          var stringToAdd = getWorkspaceInputKey(ws, i);
          var newString = stringToAdd + htmlToChange;
          mw.setHtml(i, newString);
          return ws;
        };

      case 'take-workspace--append-dom':
        return function takeDomPutWorkspacePutDom(mw, ws, i) {
          var htmlToChange = mw.getHtml(i);
          var stringToAdd = getWorkspaceInputKey(ws, i);
          var newString = htmlToChange + stringToAdd;
          mw.setHtml(i, newString);
          return ws;
        };

      default:
        throw "RS-UnknownInstructionType: received unknown instruction type `" + instruction.type + "`.";
    }
  }

  function runInstruction(mw, ws) {
    return function applyInstruction(instruction) {
      var instructionExecutor = chooseInstructionExecutor(instruction);
      var updatedWorkspace = instructionExecutor(mw, ws, instruction);
      ws = updatedWorkspace;
    };
  }

  function runInstructionSequence(mw) {
    return function runInstructionsSafely(instructions) {
      try {
        var workspace = {};
        instructions.forEach(runInstruction(mw, workspace));
      } catch(e) {
        mw.logError(e, e);
      }
    };
  }

  var validEnhancements = enhancements.filter(isValidEnhancement(middleware));
  var rsTest = middleware.getRsParams()['rs-test'];
  var userInputtedBadId = validEnhancements.length == 0 && rsTest;
  if (userInputtedBadId) {
    var testEnhancements = enhancements.filter(function(e) {
      return Number(e.id) === Number(rsTest);
    });
    var realEnhancementButWrongPath = testEnhancements.length > 0;
    if (realEnhancementButWrongPath) {
      var e = testEnhancements[0];
      middleware.logError('RS-Error: Enhancement with id ' + rsTest + " isn't configured to run on this page. If this is not correct behavior, double check your enhancement's filter.", 'rs-test picked wrong id');
      middleware.logError('Filter type:  ' + e.filter.type, 'rs-test bad filter type');
      middleware.logError('Filter value: ' + e.filter.value, 'rs-test bad filter value');
      middleware.logError('Current path: ' + middleware.getCurrentPath(), 'rs-test bad filter curr path');
    } else {
      middleware.logError('RS-Error: An enhancement with id `' + rsTest + '` does not exist. Double check the id in your rs=test=<id> request.', 'bad user input for rs-test');
    }
  }
  try {
    var chosenInstructionSequences = validEnhancements.map(chooseInstructionSequence(middleware));
    chosenInstructionSequences.forEach(runInstructionSequence(middleware));
  } catch (e) {
    middleware.logError(e, e);
  }
}
function makeMiddleware(){
  function getCurrentPath() {
    if (window.location.search) {
      var queryParams = JSON.parse('{"' + decodeURI(window.location.search.slice(1)).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g,'":"') + '"}');
      for (var key in queryParams) {
        if (key.indexOf('rs-') === 0) {
          delete queryParams[key];
        }
      }
      var newQueryParams = Object.keys(queryParams).map(function(key) {
      return decodeURIComponent(key + '=' + queryParams[key])
  }).join('&');
      if (newQueryParams.length > 0) {
        // need to append '?'
        newQueryParams = '?' + newQueryParams;
      }
      return decodeURIComponent(window.location.pathname + newQueryParams);
    } else {
      return decodeURIComponent(window.location.pathname);
    }
  }

  function getRsParams() {
    if (!window.location.search) return {};

    var params = JSON.parse('{"' + decodeURI(window.location.search.slice(1)).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g,'":"') + '"}');
    for (var key in params) {
      var notAnRsParam = key.indexOf('rs-') !== 0;
      if (notAnRsParam) {
        delete params[key];
      }
    }
    return params;
  }

  function chooseInstructionSequence(en, path) {
    const rsParams = getRsParams();
    if (rsParams['rs-recipe']) {
      const recipeId = rsParams['rs-recipe'];
      const ids = en.recipes.map(function (r) {
        return r.id.toString();
      });
      if (ids.indexOf(recipeId) === -1) {
        throw 'RS-Error: Recipe with id `' + recipeId + '` does not exist. Double check the id in your rs=recipe=<id> request.';
      } else {
        return en.recipes[ids.indexOf(recipeId)].instructions;
      }
    } else {
      var assignment = getAssignment(en.id, en.recipes, path);
      return en.recipes[assignment].instructions;
    }
  }

  function setHtml(i, value) {
    var selected = document.querySelector(i.selector); // discard any item that's not first
    var nothingSelected = selected === null;
    if (nothingSelected) {
      throw "RS-MissingHtmlElementError: can't find element with selector `" + i.selector + "`.";
    }

    function logSetHtmlBeforeAndAfter(before, after) {
      logError('Value before enhancement: ' + before, 'rs-test before');
      logError('Value after enhancement:  ' + after, 'rs-test after');
    }

    reg.register(selected);

    switch (i.method) {
      case 'Inner Text':
        logSetHtmlBeforeAndAfter(selected.textContent, value);
        return selected.textContent = value;
      case 'Outer HTML':
        logSetHtmlBeforeAndAfter(selected.outerHTML, value);
        return selected.outerHTML = value;
      case 'Attribute':
        if (!i.attr_key) {
          throw "RS-MissingAttributeKeyError: A `method` of `Attribute` requires an `attr_key`.";
        }
        logSetHtmlBeforeAndAfter(selected.getAttribute(i.attr_key), value);
        return selected.setAttribute(i.attr_key, value);
      default:
        throw "RS-UnknownSetMethod: method `" + i.method + "` not recognized.";
    }
  }

  var getHtmlCache = {};

  function getHtml(i) {
    var selected = document.querySelector(i.selector); // discard any item that's not first
    var nothingSelected = selected === null;
    if (nothingSelected) {
      throw "RS-MissingHtmlElementError: can't find element with selector `" + i.selector + "`.";
    }

    var key = getCurrentPath() + ':' + i.selector + ':' + i.method + ':' + i.attr_key;
    if (getHtmlCache[key]) {
      return getHtmlCache[key];
    }

    switch (i.method) {
      case 'Inner Text':
        getHtmlCache[key] = selected.textContent;
        return selected.textContent;
      case 'Outer HTML':
        getHtmlCache[key] = selected.outerHTML;
        return selected.outerHTML;
      case 'Attribute':
        if (!i.attr_key) {
          throw "RS-MissingAttributeKeyError: A `method` of `Attribute` requires an `attr_key`.";
        }
        var val = selected.getAttribute(i.attr_key);
        if (val) {
          getHtmlCache[key] = val;
          return val;
        } else {
          throw "RS-MissingAttributeError: Can't find attribute `" + i.attr_key + "` on element with selector `" + i.selector + "`.";
        }
      default:
        throw "RS-UnknownExtractionMethod: method `" + i.method + "` not recognized.";
    }
  }

  function createRegistry() {
    var registry = [];

    function register(node){
      if (registry.indexOf(node) > -1) {
        return;
      }
      registry.push(node);
    }

    function shouldRepaint(mutation) {
      var idx = registry.indexOf(mutation.target);

      if (idx > -1) {
        registry.splice(idx, 1);
        return false;
      }

      var removedNodes = Array.prototype.slice.call(mutation.removedNodes)
      var removedNodesInRegistry = removedNodes.filter(function(node) {
        return registry.indexOf(node) > -1;
      });
      if (removedNodesInRegistry.length > 0) {
        removedNodesInRegistry.forEach(function(node) {
          var idx = registry.indexOf(node);
          registry.splice(idx, 1);
        });
        return false;
      }

      return true;
    }

    return {
      register: register,
      shouldRepaint: shouldRepaint
    };
  }

  var reg = createRegistry();

  function painter(_paint) {
    var alreadyReceivedPaintRequest = false;
    return function bufferPaint() {
      if (alreadyReceivedPaintRequest) return;
      alreadyReceivedPaintRequest = true;
      requestAnimationFrame(function() {
        _paint();
        alreadyReceivedPaintRequest = false;
      });
    };
  }

  function registerPainter(paint) {
    var bufferPaint = painter(paint);
    function onMutations(mutations) {
      mutations.forEach(function maybeRepaint(mutation) {
        var shouldRepaint = reg.shouldRepaint(mutation);
        if (shouldRepaint) {
          bufferPaint();
        }
      });
    }

    var observer = new MutationObserver(onMutations);
    observer.observe(document, { childList: true, subtree: true, attributes: true });
  }

  var idempotenceCache = [];

  function logError(m, idempotenceId) {
    const s = window.location.search;
    if (s.indexOf('rs-verbose=true') > -1 || s.indexOf('rs-test=') > -1 || s.indexOf('rs-deactivate') > -1 || s.indexOf('rs-recipe=') > -1) {
      var shouldntLogIdempotentLog = idempotenceId && idempotenceCache.indexOf(idempotenceId) > -1;
      if (shouldntLogIdempotentLog) {
        return;
      } else {
        idempotenceCache.push(idempotenceId);
        console.warn(m);
      }
    }
  }

  return {
    getCurrentPath: window.__rsOverrides__ && window.__rsOverrides__.getPath ? window.__rsOverrides__.getPath : getCurrentPath,
    chooseInstructionSequence: chooseInstructionSequence,
    setHtml: setHtml,
    getHtml: getHtml,
    registerPainter: registerPainter,
    logError: logError,
    getRsParams: getRsParams,
  };
}
function getAssignment(id, recipes, path) {

  function md5cycle(x, k) {
  var a = x[0], b = x[1], c = x[2], d = x[3];

  a = ff(a, b, c, d, k[0], 7, -680876936);
  d = ff(d, a, b, c, k[1], 12, -389564586);
  c = ff(c, d, a, b, k[2], 17,  606105819);
  b = ff(b, c, d, a, k[3], 22, -1044525330);
  a = ff(a, b, c, d, k[4], 7, -176418897);
  d = ff(d, a, b, c, k[5], 12,  1200080426);
  c = ff(c, d, a, b, k[6], 17, -1473231341);
  b = ff(b, c, d, a, k[7], 22, -45705983);
  a = ff(a, b, c, d, k[8], 7,  1770035416);
  d = ff(d, a, b, c, k[9], 12, -1958414417);
  c = ff(c, d, a, b, k[10], 17, -42063);
  b = ff(b, c, d, a, k[11], 22, -1990404162);
  a = ff(a, b, c, d, k[12], 7,  1804603682);
  d = ff(d, a, b, c, k[13], 12, -40341101);
  c = ff(c, d, a, b, k[14], 17, -1502002290);
  b = ff(b, c, d, a, k[15], 22,  1236535329);

  a = gg(a, b, c, d, k[1], 5, -165796510);
  d = gg(d, a, b, c, k[6], 9, -1069501632);
  c = gg(c, d, a, b, k[11], 14,  643717713);
  b = gg(b, c, d, a, k[0], 20, -373897302);
  a = gg(a, b, c, d, k[5], 5, -701558691);
  d = gg(d, a, b, c, k[10], 9,  38016083);
  c = gg(c, d, a, b, k[15], 14, -660478335);
  b = gg(b, c, d, a, k[4], 20, -405537848);
  a = gg(a, b, c, d, k[9], 5,  568446438);
  d = gg(d, a, b, c, k[14], 9, -1019803690);
  c = gg(c, d, a, b, k[3], 14, -187363961);
  b = gg(b, c, d, a, k[8], 20,  1163531501);
  a = gg(a, b, c, d, k[13], 5, -1444681467);
  d = gg(d, a, b, c, k[2], 9, -51403784);
  c = gg(c, d, a, b, k[7], 14,  1735328473);
  b = gg(b, c, d, a, k[12], 20, -1926607734);

  a = hh(a, b, c, d, k[5], 4, -378558);
  d = hh(d, a, b, c, k[8], 11, -2022574463);
  c = hh(c, d, a, b, k[11], 16,  1839030562);
  b = hh(b, c, d, a, k[14], 23, -35309556);
  a = hh(a, b, c, d, k[1], 4, -1530992060);
  d = hh(d, a, b, c, k[4], 11,  1272893353);
  c = hh(c, d, a, b, k[7], 16, -155497632);
  b = hh(b, c, d, a, k[10], 23, -1094730640);
  a = hh(a, b, c, d, k[13], 4,  681279174);
  d = hh(d, a, b, c, k[0], 11, -358537222);
  c = hh(c, d, a, b, k[3], 16, -722521979);
  b = hh(b, c, d, a, k[6], 23,  76029189);
  a = hh(a, b, c, d, k[9], 4, -640364487);
  d = hh(d, a, b, c, k[12], 11, -421815835);
  c = hh(c, d, a, b, k[15], 16,  530742520);
  b = hh(b, c, d, a, k[2], 23, -995338651);

  a = ii(a, b, c, d, k[0], 6, -198630844);
  d = ii(d, a, b, c, k[7], 10,  1126891415);
  c = ii(c, d, a, b, k[14], 15, -1416354905);
  b = ii(b, c, d, a, k[5], 21, -57434055);
  a = ii(a, b, c, d, k[12], 6,  1700485571);
  d = ii(d, a, b, c, k[3], 10, -1894986606);
  c = ii(c, d, a, b, k[10], 15, -1051523);
  b = ii(b, c, d, a, k[1], 21, -2054922799);
  a = ii(a, b, c, d, k[8], 6,  1873313359);
  d = ii(d, a, b, c, k[15], 10, -30611744);
  c = ii(c, d, a, b, k[6], 15, -1560198380);
  b = ii(b, c, d, a, k[13], 21,  1309151649);
  a = ii(a, b, c, d, k[4], 6, -145523070);
  d = ii(d, a, b, c, k[11], 10, -1120210379);
  c = ii(c, d, a, b, k[2], 15,  718787259);
  b = ii(b, c, d, a, k[9], 21, -343485551);

  x[0] = add32(a, x[0]);
  x[1] = add32(b, x[1]);
  x[2] = add32(c, x[2]);
  x[3] = add32(d, x[3]);

  }

  function cmn(q, a, b, x, s, t) {
  a = add32(add32(a, q), add32(x, t));
  return add32((a << s) | (a >>> (32 - s)), b);
  }

  function ff(a, b, c, d, x, s, t) {
  return cmn((b & c) | ((~b) & d), a, b, x, s, t);
  }

  function gg(a, b, c, d, x, s, t) {
  return cmn((b & d) | (c & (~d)), a, b, x, s, t);
  }

  function hh(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
  }

  function ii(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | (~d)), a, b, x, s, t);
  }

  function md51(s) {
  txt = '';
  var n = s.length,
  state = [1732584193, -271733879, -1732584194, 271733878], i;
  for (i=64; i<=s.length; i+=64) {
  md5cycle(state, md5blk(s.substring(i-64, i)));
  }
  s = s.substring(i-64);
  var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
  for (i=0; i<s.length; i++)
  tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);
  tail[i>>2] |= 0x80 << ((i%4) << 3);
  if (i > 55) {
  md5cycle(state, tail);
  for (i=0; i<16; i++) tail[i] = 0;
  }
  tail[14] = n*8;
  md5cycle(state, tail);
  return state;
  }

  /* there needs to be support for Unicode here,
   * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps
   * by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise
   * I suggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then
   * how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something
   * like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard
   * itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8
   * 8-bit unsigned value arrays.
   */
  function md5blk(s) { /* I figured global was faster.   */
  var md5blks = [], i; /* Andy King said do it this way. */
  for (i=0; i<64; i+=4) {
  md5blks[i>>2] = s.charCodeAt(i)
  + (s.charCodeAt(i+1) << 8)
  + (s.charCodeAt(i+2) << 16)
  + (s.charCodeAt(i+3) << 24);
  }
  return md5blks;
  }

  var hex_chr = '0123456789abcdef'.split('');

  function rhex(n)
  {
  var s='', j=0;
  for(; j<4; j++)
  s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
  + hex_chr[(n >> (j * 8)) & 0x0F];
  return s;
  }

  function hex(x) {
  for (var i=0; i<x.length; i++)
  x[i] = rhex(x[i]);
  return x.join('');
  }

  function md5(s) {
  return hex(md51(s));
  }

  /* this function is much faster,
  so if possible we use it. Some IEs
  are the only ones I know of that
  need the idiotic second function,
  generated by an if clause.  */

  function add32(a, b) {
  return (a + b) & 0xFFFFFFFF;
  }

  if (md5('hello') != '5d41402abc4b2a76b9719d911017c592') {
  function add32(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF),
  msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
  }
  }

  if (recipes.length === 1) return 0;

  var totalWeight = recipes.reduce(function addWeight(sum, r) {
    return sum + r.weight;
  }, 0);
  var hashInput = "enhancement_id=" + id + "&path=" + path;
  var hash = md5(hashInput);
  var idx = parseInt(hash[hash.length-1], 16) % totalWeight;

  var result = recipes.reduce(function(agg, r, i) {
    var foundCorrectPipeline = agg.sum + 1 > idx;
    if (agg.done) {
      return agg;
    } else if (foundCorrectPipeline) {
      agg.chosenInstructionIdx = i;
      agg.done = true;
    } else {
      agg.sum = agg.sum + r.weight;
    }
    return agg;
  }, {sum: 0});

  return result.chosenInstructionIdx;
}
function logHash(){console.log("RS-Hash:", "f1760344a19be83a3e32e0a376a4e0c4")}function initializer(makeMiddleware, paint, enhancements) {
  var middleware = makeMiddleware();

  function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading"){
      fn();
    } else {
      document.addEventListener('DOMContentLoaded', fn);
    }
  }

  function _paint() {
    paint(middleware, enhancements);
  }

  middleware.registerPainter(_paint);

  function init() {
    function onInit() {
      if (window.location.search.indexOf('rs-hash=true') > -1) {
        logHash();
      }
    }

    onInit();
    _paint();
  }

  ready(init);
}
initializer(makeMiddleware, paint, enhancements);})();